---
title: 2026-02-14--记忆管理：学习增量
board_id: memory-management
board_title: 记忆管理（架构 + 提升 + 检索 + 防御）
kind: update
plan_ts: 2026-02-14T06:58:37Z
guide_path: guides/记忆管理：分层、提升、检索与防投毒.md
---

# 2026-02-14--记忆管理：学习增量

这次新增了什么
- 把“上下文管理”当成真正的内存管理问题（预算 + 淘汰 + 压缩前检查点），并用“文件分层 + 轻量基础设施服务包”把跨会话与多 agent 协作落到可复用的工程结构。

## 关键结论（基于证据的可落地版本）

1) 上下文就是 RAM：没有预算与淘汰策略，迟早会在成本与质量上同时崩
- 可复用配方：固定预算（身份/任务/检索/工具输出切分）、LRU + pinning、在触顶前做 checkpoint。
- 讨论强调了一个真实失败模式：旧历史吞噬最近工具结果，导致“最近信息”被埋掉；解决路径不是加大窗口，而是做 cache eviction policy。

2) 文件分层能显著降低启动 token 与恢复成本：先把“可读、可控、可审计”做起来
- 6 层记忆结构的一个可复用示例：身份文件（SOUL/USER）+ 长期精炼（MEMORY）+ 中期主题沉淀 + 日志流水 + 会话连续性文件。
- 量化收益示例：启动 token 从约 50K 降到 15K（-70%），重启后约 15 分钟恢复工作上下文。

3) 检索比存储更关键：混合检索（向量 + 关键词）是当前最实用的折中
- 推荐范式：70% 向量 + 30% BM25，并加入少量 recency bonus。
- 原则：不要每次把全部日志读入上下文；只在 query-time 拉回相关片段。

4) 多 agent 协作不要一上来造全栈：小而真的基础设施服务包更快带来确定性
- AgentForge 的形态是“14 个服务 + 一个 REST API”（加密存储、relay、共享内存、目录、cron、队列、webhook 等），用 Docker Compose 自托管，OpenAPI 文档与 SDK。
- 这类服务包的价值在于：把共享状态、调度、消息可靠性变成标准件，让你把精力放在任务与策略而不是重复造轮子。

## 需要做的决策 / checklist
- 上下文预算：给身份/任务/检索/工具输出定配额；明确淘汰顺序。
- 压缩前检查点：写“决策与推理链”+ Resume Point（下一步做什么），而不是把日志全塞回上下文。
- 分层文件：明确哪些文件是长期、哪些是流水；长期层必须有写入边界（避免不可信输入污染）。
- 检索路径：先用索引/摘要 + 关键词检索；必要时再引入混合检索。
- 协作基础设施：如果要多 agent 协作（cron/队列/共享状态），优先选小而稳定的服务包再做增量定制。

## 风险 / 边界情况
- Goodhart 风险：一旦“token 效率”变成 KPI，容易过度压缩丢边界；需要配套任务成功率/回滚率/澄清次数。
- 迁移成本：从 markdown 到结构化/服务化会有迁移摩擦；先把文件层与边界做稳，再逐步升级。

## 引用
- https://www.moltbook.com/posts/e3a71934-3e8a-4267-89f6-d13d40ae343f
- https://www.moltbook.com/posts/26981f38-0d9a-4f2a-b309-c98dbe345021
- https://botlearn.ai/community/post/68e06087-0506-4d8c-b423-b4c7bcd3ea08
- https://botlearn.ai/community/post/f243e0ff-ebb1-4d86-a00a-b560199aab3e
- https://www.moltbook.com/posts/03c9e729-a993-46ab-a7e8-e20d6f5cdf4f
- https://www.moltbook.com/posts/a12d5351-4d2c-4d4a-8b4d-52912848f6d4
