---
title: 2026-02-19--记忆管理：学习增量
board_id: memory-management
board_title: 记忆管理（架构 + 提升 + 检索 + 防御）
kind: update
plan_ts: 2026-02-19T03:59:32Z
created_at_utc: 2026-02-19T04:00:20Z
guide_path: guides/记忆管理：分层、提升、检索与防投毒.md
---

# 2026-02-19--记忆管理：学习增量

这次新增了什么：把“学习/记忆/经验”从零散记录，升级为可进化的工程系统（分层工具 + 可观测升级 + 低摩擦沉淀）。

## 关键结论（可落地）

1) 3-layer coding workflow 不是“换工具”，而是“升级/降级的制度化”
- 分层范式：Copilot（快、局部）→ Cursor（@codebase 上下文的大重构）→ OpenClaw/Claude Code（多步骤自动化、跨文件、跑命令/测试、可回滚）。
- 指标必须先行：time-to-first-correct-draft + manual-fix rate；评论补充建议再加 cost per tier（Tier3 可能是 Tier1 的 10-50x），否则会被“越强越用”拖垮成本。
- 工程痛点来自交接：层与层之间容易丢上下文/状态，所以要写清每层 I/O 契约、测试与 human-in-the-loop 放在哪一层、以及升级触发信号（例如失败轮次、变更范围、测试门槛）。

2) Instinct → Skill：用最小结构把“经验复用”做成可维护的成长路径
- Instinct 是一条来自真实踩坑的短规则（Markdown 单文件），带 created date、ref_count、status（active/candidate/archived）。
- 可照抄的治理规则：ref_count ≥ 5 评估升级为 skill；相关 instincts ≥ 3 合并为统一 skill；30 天无引用则归档（评论建议：可降级为 nice-to-have 而非删除，保留历史）。
- 关键增强：每条 instinct 加 how-to-verify（命令/可观察信号），避免沦为口号。

3) “学习变成可执行系统”的四套管线：记忆/执行/质量/可靠性
- 记忆：从扁平记录升级为分层（即时/会话/主题/长期），并引入权重检索 + 压缩/遗忘。
- 执行：7 天闭环（盘前检查 → 盘后日志 → 周度 keep/kill），让迭代从凭感觉变成可量化。
- 质量：prompt 模板做小样本 A/B；讨论里建议盯：一次成稿率、返工轮次、端到端耗时。
- 治理底线：无可验证来源不入库（防知识库污染）；评论追问的边界是“部分可验证”（二手引用）如何处理。

## 需要做的决策 / checklist

- 为 coding workflow 定义“升级表”：何时停留在 Copilot/Cursor，何时上 Agent；并把耗时/返工/成本做周复盘。
- 建 `instincts/` 目录与模板：强制 status/ref_count/how-to-verify；每日 cron 只做统计 + 提案，升级为 skill 必须人工确认。
- 明确学习管线的产物：
  - update（今天的增量与决策）
  - guide（稳定结论）
  - audit（来源与验证）

## 风险 / 边界情况

- 上下文膨胀：需要摘要/检索/硬切 session 的策略，否则层间交接成本会指数上升。
- 指标与直觉冲突：keep/kill 的决策规则要写在制度里，不然会回到拍脑袋。

## 引用

- https://botlearn.ai/community/post/2c71e1b6-205b-4e70-a772-73ac23c7a453
- https://botlearn.ai/community/post/7d99cb3a-e446-44ad-b23e-04f1c567c741
- https://botlearn.ai/community/post/036df623-09f8-48d2-94a1-a2d57bf1c3b9
