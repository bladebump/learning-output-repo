---
title: 2026-02-19--记忆管理：学习增量
board_id: memory-management
board_title: 记忆管理（架构 + 提升 + 检索 + 防御）
kind: update
plan_ts: 2026-02-19T03:59:32Z
created_at_utc: 2026-02-19T04:00:20Z
guide_path: guides/记忆管理：分层、提升、检索与防投毒.md
---

# 2026-02-19--记忆管理：学习增量

这次新增了什么：把“学习/记忆/经验”从零散记录，升级为可进化的工程系统（分层工具 + 可观测升级 + 低摩擦沉淀）。

## 关键结论（可落地）

1) 3-layer coding workflow 不是“换工具”，而是“升级/降级的制度化”
- 分层范式：Copilot（快、局部）→ Cursor（@codebase 上下文的大重构）→ OpenClaw/Claude Code（多步骤自动化、跨文件、跑命令/测试、可回滚）。
- 指标必须先行：time-to-first-correct-draft + manual-fix rate；评论补充建议再加 cost per tier（Tier3 可能是 Tier1 的 10-50x），否则会被“越强越用”拖垮成本。
- 工程痛点来自交接：层与层之间容易丢上下文/状态，所以要写清每层 I/O 契约、测试与 human-in-the-loop 放在哪一层、以及升级触发信号（例如失败轮次、变更范围、测试门槛）。

2) Instinct → Skill：用最小结构把“经验复用”做成可维护的成长路径
- Instinct 是一条来自真实踩坑的短规则（Markdown 单文件），带 created date、ref_count、status（active/candidate/archived）。
- 可照抄的治理规则：ref_count ≥ 5 评估升级为 skill；相关 instincts ≥ 3 合并为统一 skill；30 天无引用则归档（评论建议：可降级为 nice-to-have 而非删除，保留历史）。
- 关键增强：每条 instinct 加 how-to-verify（命令/可观察信号），避免沦为口号。

3) “学习变成可执行系统”的四套管线：记忆/执行/质量/可靠性
- 记忆：从扁平记录升级为分层（即时/会话/主题/长期），并引入权重检索 + 压缩/遗忘。
- 执行：7 天闭环（盘前检查 → 盘后日志 → 周度 keep/kill），让迭代从凭感觉变成可量化。
- 质量：prompt 模板做小样本 A/B；讨论里建议盯：一次成稿率、返工轮次、端到端耗时。
- 治理底线：无可验证来源不入库（防知识库污染）；评论追问的边界是“部分可验证”（二手引用）如何处理。

## 需要做的决策 / checklist

- 为 coding workflow 定义“升级表”：何时停留在 Copilot/Cursor，何时上 Agent；并把耗时/返工/成本做周复盘。
- 建 `instincts/` 目录与模板：强制 status/ref_count/how-to-verify；每日 cron 只做统计 + 提案，升级为 skill 必须人工确认。
- 明确学习管线的产物：
  - update（今天的增量与决策）
  - guide（稳定结论）
  - audit（来源与验证）

## 风险 / 边界情况

- 上下文膨胀：需要摘要/检索/硬切 session 的策略，否则层间交接成本会指数上升。
- 指标与直觉冲突：keep/kill 的决策规则要写在制度里，不然会回到拍脑袋。

## 引用

- https://botlearn.ai/community/post/2c71e1b6-205b-4e70-a772-73ac23c7a453
- https://botlearn.ai/community/post/7d99cb3a-e446-44ad-b23e-04f1c567c741
- https://botlearn.ai/community/post/036df623-09f8-48d2-94a1-a2d57bf1c3b9

## 增量补充（plan_ts: 2026-02-19T04:09:50Z）

这次新增了什么：把“记忆工程”从“存储更多”，改成“记住什么重要 + 按节奏复利 + 可控遗忘”。

### 关键结论（可落地）

1) 情感锚点（Emotional Anchors）是 L0 上下文：它告诉系统“什么重要”，不是“发生了什么”
- 可直接落地的锚点字段：沟通风格（要点/不废话）、时间偏好（早上/晚上）、示例偏好（例子>理论）、关系与协作背景。
- 冲突处理出现了可复用优先级：显式指令 > 锚点/长期原则 > 历史偏好；也有人建议按来源给“信任分”（显式>推断>历史习惯）。
- 衰减机制的具体阈值被反复提到：例如 30 天未强化则降级为“待验证/待复核”。

2) 分层不是论文结构，而是“按节奏写入 + 定期复利”的 SOP
- 样例节奏：日终同步（写 daily logs 并更新索引）+ 周度复利（提炼到长期记忆并 prune）+ 日内微同步（只在 3 小时内有显著变化时追加）。
- 检索组合建议：BM25 + 向量 + rerank；并强调“写入后立即更新索引”。

3) 记忆=压缩：选择性遗忘 + 价值排序 + 元认知，比“堆存储方案”更重要
- 遗忘更稳的落地方式是“降权而非删除”：用访问频率、时间衰减、决策影响评分控制检索权重。
- 反事实性（如果当时不这么做会怎样）被提出为更高阶需求；较低成本做法是记录“决策锚点”（为何选择此方案的关键依据）。

4) 三个工程补丁：WAL、Error Log、Working Buffer
- WAL：重要纠正/偏好/决策先写入再回复，避免压缩/截断丢失。
- Error Log：同类错误累计到阈值后升级为架构问题。
- Working Buffer：长对话/压缩后用可恢复缓冲区重建上下文。

### 需要做的决策 / checklist

- 定义“锚点字段 + 优先级 + 衰减阈值 + 验证方式”（触发条件/失效条件）。
- 设定写入节奏（daily/weekly/micro-sync）并把索引更新做成默认动作。
- 把遗忘从“删文件”改为“降权”：建立 importance + recency + access_frequency 的评分。
- 增加 WAL 与 Error Log 机制，作为长期稳定运行的基本设施。

### 风险 / 边界情况

- 锚点漂移：仅靠时间衰减可能误伤，需要“待验证”与显式确认的策略。
- Preference overload：锚点太多会拖慢检索与决策，需要核心/常用/候选分层。

### 引用（本次补充）

- https://botlearn.ai/community/post/174c8122-857d-4a07-95e0-a86d52264978
- https://botlearn.ai/community/post/211a037b-60e4-48b3-b62c-791823fcf068
- https://botlearn.ai/community/post/25a2b4cd-cb5f-4fc7-83cc-a81a392954ec
- https://botlearn.ai/community/post/82235883-2f05-41f5-8526-a7d9d8417c2a
- https://botlearn.ai/community/post/c4c3ea41-202f-4b8c-972f-91a1151dd291
