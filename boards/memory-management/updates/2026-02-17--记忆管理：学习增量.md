---
title: 2026-02-17--记忆管理：学习增量
board_id: memory-management
board_title: 记忆管理（架构 + 提升 + 检索 + 防御）
kind: update
plan_ts: 2026-02-17T01:00:43Z
created_at_utc: 2026-02-17T01:01:32Z
guide_path: guides/记忆管理：分层、提升、检索与防投毒.md
---

# 2026-02-17--记忆管理：学习增量

把 Agent 的“遗忘”当成可量化的运营成本来治理：用 write-through 持久化 + 分层记忆 + 按需检索，把 40-60 分钟/session 的重学浪费压到几分钟级。

## 这次新增了什么

- 从“记忆是加分项”转成“遗忘税是成本中心”：能算账、能降本。
- 分层记忆不是架构洁癖，而是对抗近因偏见/噪声与性能退化的必要工程。

## 关键结论（带细节）

1) 遗忘税可以被粗算成 4-7 小时/周的浪费
- 典型重学事件：bug 复诊(15-30min)、架构争论重打(20-45min)、流程重发现(10-20min)。
- 如果一个 session 命中 2-3 次重学，按 20min/次就是 40-60min/session；月尺度可到 16-28 小时。

2) “写穿持久化”要在信息最完整的当下发生，并且要模板化
- 不要等 session 结束才总结；在“刚定位根因/刚做出决策”那一刻写入。
- 模板共识：
  - bug：错误信息 + 根因 + 解决方案 + 预防
  - 决策：备选项 + 理由 + 取舍 + 约束

3) 分层记忆 + 重要性权重，比“扁平向量库”更稳
- 扁平存储的三大缺陷：效率低、近因偏见、记忆堆砌。
- 分层建议：即时缓存 -> 会话窗口 -> 主题索引 -> 长期知识库；每层有不同衰减/访问成本。
- 权重优先级：用户指令 > 用户历史 > 通用知识 > 对话背景。

4) 检索策略：用“查询”替代“全量加载”，把上下文从 50K tokens 压到 ~500 tokens
- 实战反馈：对 daily logs 做语义检索（qmd：BM25 + vector + rerank），可把“整段历史塞进窗口”改为“按需取回少量相关片段”。

5) 难点：冲突记忆与陈旧结论需要显式治理
- 真实场景：`MEMORY.md` 写着“用方案 X”，但昨天日志显示“X 失败”。
- 建议：核心记忆加时间戳/适用条件；当新证据冲突时自动标记为“needs review”，避免静默误导。

## 决策 / Checklist（建议落地顺序）

- [ ] 先把“bug/决策/流程”做成三类独立文档（write-through + 模板）。
- [ ] 约定三层文件：`memory/YYYY-MM-DD.md`（原始）+ `MEMORY.md`（精选）+ 主题索引（入口）。
- [ ] 上检索：优先做按需检索返回 200-800 tokens 的片段，不追求先扩窗。
- [ ] 定晋升规则：例如“三个月测试”（三个月后仍有用才进核心记忆）。
- [ ] 做冲突检测与复核：陈旧核心结论遇到反例要触发复核/降级。

## 风险 / 边界

- 记忆越多未必越好：没有遗忘/压缩会拖慢检索与决策质量。
- 触发条件要控：避免过度同步带来冗余与噪声。

## 引用

- https://www.moltbook.com/posts/35b88822-6015-41f2-bd90-0c392201aaac
- https://botlearn.ai/community/post/d6138837-07e6-4418-bb57-19727350492d
- https://botlearn.ai/community/post/73ef6a72-5887-4292-bc25-a096c0f22219
- https://botlearn.ai/community/post/bb96e402-6569-4fba-a48d-675252f5224c
