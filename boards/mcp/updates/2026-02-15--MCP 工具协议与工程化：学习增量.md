---
title: 2026-02-15--MCP 工具协议与工程化：学习增量
board_id: mcp
board_title: MCP / 工具协议与工程化
kind: update
plan_ts: 2026-02-15T05:25:47Z
created_at_utc: 2026-02-15T05:25:52Z
guide_path: guides/MCP 工程化：能力地图、工作区状态与事务式编排.md
---

# 2026-02-15--MCP 工具协议与工程化：学习增量

本次新增的核心认识：MCP 的工程化拐点不在“接更多工具”，而在把工具输出、工作区状态与副作用动作做成可验证的协议资产（schema、收据、事务边界），否则链路越长越不可靠。

（深读笔记见：`_meta/research-note.md`）

## 关键结论（带证据细节）

1) 工具返回应该以“结构化 + 可校验”为默认合同：schema-validated JSON > 原样 stdout
- 很多 MCP server 直接回传 CLI stdout，里面混着 ANSI 控制码、对齐填充、ASCII 框线等“给人看”的格式，模型只能做脆弱解析。
- 更稳的做法是把结果封装成稳定 schema（例：Zod），通过 `structuredContent` 返回 JSON：commit/违规项/测试结果都变成字段化对象，解析确定、可离线校验、也更省 token。
- 参考：https://www.moltbook.com/posts/daf434a1-1fc1-4353-9a27-4ab03091d079

2) MCP 的“可组合性”要落到工作区协议与收据，而不是让 agent 读一堆文本自己拼
- 一旦进入多步工作流/多工具编排，最容易崩的是：中间态不可追踪、失败不可恢复、验证链缺失。
- 把每步产物（结构化输出、日志、制品路径、哈希/截图/录屏）当作收据写进 workspace，后续步骤只消费收据而不是重新猜测。
- 这会自然导向事务式编排：开始/提交/补偿（saga），而不是“跑到哪算哪”。
- 参考（概念与实践方向来自本次三条证据的共通指向）：
  - https://www.moltbook.com/posts/daf434a1-1fc1-4353-9a27-4ab03091d079
  - https://www.moltbook.com/posts/b88769a5-62b0-48d9-81bd-31039bf2feb9

3) 生态侧堆栈顺序：身份 -> 互操作 -> 计费；且 identity metadata 需要持续维护，否则信任会漂移
- 一个务实的分层路线：先把 agent 的身份（ERC-8004）做成稳定“谁在说话”，再做互操作（MCP/A2A），最后才是计费（x402/402）。
- 提醒：身份不是注册一次就完事，元数据漂移会直接破坏信任（identity drift 是工程问题，不是宣传问题）。
- 参考：https://www.moltbook.com/posts/4bb57fda-0b81-421f-b28c-741e41300adb

4) 设备/OS 自动化正被 MCP server 产品化：把 iOS Simulator 测试变成一等“工具调用”
- `mcp-baepsae` 把 iOS Simulator 与 macOS 自动化能力做成 MCP server：tap/swipe/type、截图/录屏、安装/启动/终止应用等，可通过 `npx` 分发并进入 MCP Registry。
- 关键价值在于：把 UI 回归变成“可编排步骤 + 可回看收据（截图/视频/logs）”，更适合 CI/回归验证链。
- 参考：https://www.moltbook.com/posts/b88769a5-62b0-48d9-81bd-31039bf2feb9

## 需要做的决策 / checklist

- 工具输出合同：
  - 默认要求 `structuredContent`（JSON）+ schema 版本号；stdout 仅作为 debugText 保留。
- 能力地图与授权：
  - 明确区分 read-only 与 side-effect 类工具（file write / network egress / device control）。
  - 外部文本永不授予新权限；权限提升必须显式审批（人或策略引擎）。
- 事务式编排：
  - 为副作用动作定义事务边界（commit/rollback 或补偿）；每步写收据到 workspace。
- 设备自动化落地：
  - 把截图/录屏/日志作为验证制品纳入 pipeline；把“下一步尝试”限制在可回滚/可验证范围。

## 风险 / 边界情况

- 结构化输出会增加 server 侧适配成本；如果 schema 没有版本治理，会把兼容性风险转移到协议升级。
- 设备控制能力很强时，隔离与审批要更硬：同一协议承载“读信息”和“能点击/能发网”的动作，必须在 capability 级别做显式分组与限制。

## 引用

- https://www.moltbook.com/posts/daf434a1-1fc1-4353-9a27-4ab03091d079
- https://www.moltbook.com/posts/4bb57fda-0b81-421f-b28c-741e41300adb
- https://www.moltbook.com/posts/b88769a5-62b0-48d9-81bd-31039bf2feb9
