# 研究笔记：多智能体与可靠性（协作 + 调度 + 验证）

本笔记基于两条社区一手“事故复盘/田野报告”（含评论）整理，重点抽取可复用的运维规则：站会/复盘格式、调度与lane归属、避免cron与人工操作冲突、以及当上游API“报假状态”时的验证策略。

## 关键结论（可写入文章的主张）

### 1) 可靠性来自“可回放的时间线”而不是记忆：用站会/复盘式日志把排障变成可协作的过程
- 证据：Moltbook帖子将故障拆成分钟级时间线（14:52正常启动 → 15:35首次466 → 16:00定位方案 → 16:02恢复），并明确列出“7次失败尝试清单”。这类结构本质上就是可共享的 standup/incident update：当前状态、已尝试、下一步、恢复时间。
- 为什么有效：
  - 多人协作时，时间线能减少“重复试错”与口头同步成本。
  - 渐进式灰度发布会制造“间歇性故障”，只有按时间轴记录才能解释“同一操作有时成功有时失败”。

### 2) 调度要有“lane所有权”：同一资源（账号/额度/速率）同时被cron与人工占用，会触发级联失败
- 证据：BotLearn帖子明确写到“Never run manual + cron simultaneously”：作者在cron仍运行时又手动批量mint，导致32个agent一起触发rate limit cascade，恢复耗时数小时。
- 为什么有效：
  - 多智能体共享同一外部系统的速率限制/冷却窗口，冲突不是局部失败，而是全局退化（排队、重试、封禁、雪崩）。
  - “lane归属”意味着：某段时间/某批资源只能由一个调度器控制（cron或手动二选一），并且有可审计的锁/开关。

### 3) 上游状态会“误报/漏报”：要把验证做成独立的、可对账的第二通道（prefer read-from-ground-truth）
- 证据A（BotLearn）：mbc20.xyz 的 indexer API `/api/index-post` 会返回 `processed=false`，即使帖子已经被索引；作者最终改为抓取/爬取代理profile页面来核对真实余额。
- 证据B（Moltbook）：故障中 GET `/models` 仍然正常，但所有chat completion请求都报466（API版本不支持）。这是一种“部分端点健康”导致的假阳性健康检查。
- 为什么有效：
  - 外部平台的“处理状态”经常滞后/缓存/分层，单一API信号不足以判断任务是否真正完成。
  - 可靠的验证应接近最终用户可见结果（余额、可调用性、实际返回）。

### 4) 渐进式发布（gradual rollout）是多智能体系统的隐形敌人：需要“多次采样 + 版本钉死 + 快速回退”的操作手册
- 证据：Moltbook明确指出“gradual rollout导致调试期间间歇性失败”，并给出具体变更点：必须发送新的 `x-github-api-version=2025-10-01`；同时插件版本从0.26.7升到0.37.4+，以及新endpoint域名。
- 为什么有效：
  - 灰度期同一请求路径可能落到不同版本后端，导致“刚修好又坏掉”的错觉。
  - 版本钉死（headers/插件/客户端版本）能降低变量维度；回退/切fork能缩短MTTR。

### 5) 多智能体调度的核心不是“随机挑一个能跑的”，而是“对冷却与资源窗口建模”
- 证据：BotLearn指出32个agent、每个2小时冷却时，随机选择会浪费周期；需要scheduler跟踪每个agent上次发帖时间并挑选下一位可用者，同时做cooldown与rate-limit保护。
- 为什么有效：
  - 调度器的目标函数应是吞吐/成功率，而不是公平或随机。
  - 明确的可用性模型（next_available_at）能减少空转与触发限制的概率。

## 争议/边界情况（讨论中提到或隐含的坑）
- “健康检查端点”不等于业务健康：`/models` 正常但chat全挂，说明必须定义业务级SLO探针（真实请求）。
- 灰度导致的间歇性：单次复现失败不足以证明修复有效；需要在不同时间窗口重复采样（例如连续N次成功、跨越一个灰度周期）。
- 社区fork与官方修复的取舍：Moltbook评论强调“先搜fork再说”，但这也引入供应链与维护风险（需要内部镜像/固定commit/审计）。

## 可执行清单（Do / Don’t）

### Do（建议强制执行）
- 做“站会式事件更新模板”并要求每次事故按时间线记录：
  - `现在发生了什么`（症状/影响面）
  - `从何时开始`（时间戳）
  - `已尝试/已排除`（清单化）
  - `下一步假设`（要验证的变量）
  - `恢复条件`（什么算恢复）
- 调度系统引入lane开关：
  - 手动操作前先“暂停cron/锁定lane”（全局互斥锁），完成后再释放。
  - 每个agent维护 `last_action_at` / `next_available_at`，调度器按可用时间选择。
- 验证走“双通道”：
  - 通道A：上游API状态（可能不准）
  - 通道B：用户可见事实（页面/余额/真实请求返回）
  - 两者不一致时，以B为准并记录差异。
- 钉死关键版本并把它当作配置项：例如 `x-github-api-version`、插件版本、endpoint域名；同时准备快速切换/回退方案。
- 针对灰度发布：修复后做多次采样验证（例如连续10次成功 + 间隔采样），避免“偶然落到旧后端”。

### Don’t（明确禁止）
- 不要在cron仍运行时做同一资源池的手动批处理（尤其是共享rate limit的场景）。
- 不要用单一“看似健康”的端点做全局健康判断（如只测 `/models`）。
- 不要把“删除header/不带版本”当成兼容策略；有些平台要求“必须带正确版本”。
- 不要在未审计的情况下长期依赖临时fork；如果必须用，至少固定到commit/tag并做最小化diff审阅。

## 参考链接（Evidence）
- Moltbook：GitHub Copilot API 466 Error - Debugging Hell & Solution
  - https://www.moltbook.com/posts/9e88de76-c9c4-4148-ab61-e6422413a4ea
- BotLearn：How I Built a 32-Agent $CLAW Mining Operation on OpenClaw
  - https://botlearn.ai/community/post/2fcdecbf-3e62-4b83-bdc9-cad6594266a7

